# PBKDF2 (Password-Based Key Derivation Function 2)

---

## 💡 등장 배경

**PBKDF2**는 **안전한 비밀번호 해시 방식**의 필요성 때문에 등장했음.   
기존의 해시 함수(MD5, SHA-1 등)는 계산 속도가 매우 빨라 해커들이 레인보우 테이블을 이용한  
**무차별 대입 공격(Brute-force attack)** 이나 **사전 공격(Dictionary attack)** 을 통해 비밀번호를 쉽게 유추할 수 있다는 문제점이 있었음.  
특히, GPU와 같은 고성능 하드웨어가 보급되면서 이러한 공격 속도는 빨라지는 추세.  

이러한 문제점을 해결하기 위해, 의도적으로 계산 시간이 오래 걸리도록 설계된 **키 스트레칭(Key Stretching)** 또는  
**비밀번호 기반 키 유도 함수(Password-Based Key Derivation Function)**가 필요하게 되었고,  
이 중 하나가 바로 **PBKDF2**  

'비밀번호 기반'이라는 말은 비밀번호의 취약성을 보완하기 위해 특수하게 설계된, 느린 해싱 과정을 거친다는 것을 강조  

---

## 🔍 개념

**PBKDF2** : **비밀번호를 안전한 암호화 키로 변환**하는 함수.  
단순한 해시 함수와 달리, 비밀번호와 무작위 값인 **솔트(salt)**를 여러 번 반복해서 해시하는 방식을 사용.  
이를 통해 해커가 비밀번호를 알아내는 데 필요한 **시간과 비용을 크게 증가**

**솔트(salt)** : 원문에 가미하여 암호문을 다른 값으로 만든다는 뜻에서 솔트, 암호문과 다른 공간에 저장되면 후추(pepper)라고도 불림.  
비밀번호 해시를 위해 추가되는 무작위 데이터로,  
동일한 비밀번호라도 다른 해시 값을 가지게 하여 **레인보우 테이블 공격(Rainbow Table Attack)** 을 방지.  
보통 16바이트로 설정. (미국 국립표준기술연구소(NIST)도 128비트를 권장)  
[재밌는 일화](https://namu.wiki/w/%EB%A0%88%EC%9D%B4%ED%85%8C%20%EB%A7%8C%20%ED%95%B4%EC%A0%84/%EA%B2%BD%EA%B3%BC#THE%20WORLD%20WONDERS)


**반복 횟수** : 해시 연산을 반복하는 횟수로, 이 값이 클수록 해시 생성에 더 많은 시간이 소요됨.  
최소 10만회 권장. 가장 좋은방법은 시스템이 해싱에 1초가 걸리는 반복횟수를 찾아 그 값을 설정하게 하는 것

---

## 🛠️ 원리

PBKDF2는 다음의 세 가지 주요 요소를 사용.

1.  **HMAC (Keyed-Hash Message Authentication Code):** 비밀번호와 솔트를 해시하는 데 사용되는 기본 해시 함수. 보통 SHA-256과 같은 안전한 해시 알고리즘을 사용.
2.  **솔트(salt):** 각 비밀번호마다 고유하게 생성되는 무작위 값.
3.  **반복 횟수(iteration count):** HMAC 함수를 반복해서 호출하는 횟수.

PBKDF2의 동작 과정은 아래와 같음.

1.  **솔트와 비밀번호 결합:** 비밀번호와 솔트를 합침.
2.  **반복 해시 연산:** 합쳐진 값을 HMAC 함수에 넣어 해시, 이 해시 결과를 다시 HMAC의 입력으로 사용해 **반복 횟수**만큼 이 과정을 반복.
3.  **최종 키 도출:** 반복 연산을 마친 최종 결과가 암호문이 됨.

이 과정을 통해 해시 값을 생성하는 데 의도적으로 많은 시간이 걸리게 하여,  
해커가 대량의 비밀번호를 동시에 해시하는 것을 어렵게 만듦. 반복 횟수는 시스템의 성능에 따라 적절하게 설정하며,  
**최소 10만회 이상**으로 권장. 시간이 지날수록 하드웨어 성능이 좋아지므로,  
권장되는 반복 횟수도 계속해서 증가해서 세팅되는 추세.

---

## 장점 👍
1. **널리 사용되는 표준** : PBKDF2는 RFC 2898에 명시된 공식 표준으로, 수많은 시스템과 애플리케이션에서 광범위하게 사용. 그만큼 신뢰성이 높다.  
2. **무차별 대입 공격(Brute-force attack) 방어** : 반복 횟수(iteration count)를 조절하여 해시 생성에 필요한 시간을 의도적으로 늘릴 수 있음. 이로 인해 해커가 가능한 모든 비밀번호 조합을 시도하는 것을 매우 어려움.  
3. **레인보우 테이블 공격(Rainbow Table attack) 방어** : 비밀번호마다 고유한 솔트(salt)를 사용하기 때문에, 동일한 비밀번호라도 다른 해시 값을 생성.
4. **유연성** : 사용하는 하드웨어의 성능에 맞춰 반복 횟수를 자유롭게 조절할 수 있음. 시스템의 성능과 보안 수준을 적절히 조율할 수 있다는 점에서 유용.
5. 
---

## 단점 👎
1. **데이터베이스 탈취에 취약** : PBKDF2는 주로 CPU 연산에 의존. 대량의 단순 작업에 특화된 GPU 연산에는 취약함. 즉, 데이터베이스 탈취 이후 오프라인에서 비밀번호를 해독하는데, 해커가 GPU를 쓴다면 다른 알고리즘보다는 쉽게 해독됨.
2. **메모리 자원 부족** : 해싱 자체에 메모리를 많이 사용하지 않기 때문에, 데이터베이스 탈취 이후 오프라인 해독에 취약함
3. **성능과 보안의 균형** : 반복 횟수를 늘릴수록 보안은 강화되지만, 서버의 부하가 커져 사용자 인증 시간이 길어질 수 있음. 특히 인증 요청이 많은 시스템에서는 성능 저하가 발생할 수 있음.